<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="JavaScript对于作用域（Scope）和上下文（Context）的实现市这门语言的一个非常独到的地方，部分归功于其独特的灵活性。函数可以接收不同的上下文和作用域。这些概念为JavaScript中的很多强大的设计模式提供了坚实的基础。然而这些概念也非常容易给开发人员带来困惑。为此，本文将全面剖析这些概念，并阐述不用的设计模式是如何利用它们的。 上下文（Context）和作用域（Scope）首先">
<meta property="og:type" content="article">
<meta property="og:title" content="理解JavaScript中的作用域和上下文">
<meta property="og:url" content="r0ger1tlearn.com/2017/10/18/context-and-scope/index.html">
<meta property="og:site_name" content="Echoes Of The Rainbow">
<meta property="og:description" content="JavaScript对于作用域（Scope）和上下文（Context）的实现市这门语言的一个非常独到的地方，部分归功于其独特的灵活性。函数可以接收不同的上下文和作用域。这些概念为JavaScript中的很多强大的设计模式提供了坚实的基础。然而这些概念也非常容易给开发人员带来困惑。为此，本文将全面剖析这些概念，并阐述不用的设计模式是如何利用它们的。 上下文（Context）和作用域（Scope）首先">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-10-18T04:57:50.000Z">
<meta property="article:modified_time" content="2023-06-29T13:27:54.453Z">
<meta property="article:author" content="boyongjiong">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content=" React">
<meta property="article:tag" content=" Node.js">
<meta property="article:tag" content=" GraphQL">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>理解JavaScript中的作用域和上下文</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2017/10/19/asynchronous-programming/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2017/10/16/es6-class-usage/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=r0ger1tlearn.com/2017/10/18/context-and-scope/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&text=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&title=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&is_video=false&description=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=理解JavaScript中的作用域和上下文&body=Check out this article: r0ger1tlearn.com/2017/10/18/context-and-scope/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&title=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&title=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&title=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&title=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&name=理解JavaScript中的作用域和上下文&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=r0ger1tlearn.com/2017/10/18/context-and-scope/&t=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#上下文（Context）和作用域（Scope）"><span class="toc-number">1.</span> <span class="toc-text">上下文（Context）和作用域（Scope）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量作用域"><span class="toc-number">1.1.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是this上下文"><span class="toc-number">1.2.</span> <span class="toc-text">什么是this上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行环境（execution-context）"><span class="toc-number">1.3.</span> <span class="toc-text">执行环境（execution context）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域链（The-Scope-Chain）"><span class="toc-number">1.4.</span> <span class="toc-text">作用域链（The Scope Chain）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-number">1.5.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Call-和-Apply"><span class="toc-number">1.6.</span> <span class="toc-text">Call 和 Apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6中的箭头函数"><span class="toc-number">1.7.</span> <span class="toc-text">ES6中的箭头函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">2.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        理解JavaScript中的作用域和上下文
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Echoes Of The Rainbow</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2017-10-18T04:57:50.000Z" itemprop="datePublished">2017-10-18</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%90%91/">技术向</a>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>JavaScript对于作用域（Scope）和上下文（Context）的实现市这门语言的一个非常独到的地方，部分归功于其独特的灵活性。函数可以接收不同的上下文和作用域。这些概念为JavaScript中的很多强大的设计模式提供了坚实的基础。然而这些概念也非常容易给开发人员带来困惑。为此，本文将全面剖析这些概念，并阐述不用的设计模式是如何利用它们的。</p>
<h2 id="上下文（Context）和作用域（Scope）"><a href="#上下文（Context）和作用域（Scope）" class="headerlink" title="上下文（Context）和作用域（Scope）"></a>上下文（Context）和作用域（Scope）</h2><p>首先需要知道的是，上下文和作用域是两个完全不同的概念。多年来，我发现很多开发者会混淆这两个概念，错误的将两个概念混淆了。平心而论，这些年来很多术语都被混乱的使用了。</p>
<p>函数的每次调用都有与之紧密相关的作用域和上下文。从根本上来说，作用域是基于函数的，而上下文是基于对象的。换句话说，作用域涉及到所被调用函数中的变量访问，并且不用的调用场景是不一样的。上下文始终是<code>this</code>关键字的值，它是拥有（控制）当前所执行代码的对象的引用。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>一个变量可以被定义在局部或者全局作用域中，这建立了在运行时（runtime）期间变量的访问性的不同作用域范围。任何被定义的全局变量，意味着它需要在函数体的外部被声明，并且存活于整个运行时（runtime），并且在任何作用域中都可以被访问到。在ES6之前，局部变量只能存在于函数体中，并且函数的每次调用它们都拥有不同的作用域范围。局部变量只能在其被调用期的作用域范围内被赋值、检索、操纵。</p>
<p>需要注意的是，在ES6之前，JavaScript不支持块级作用域，这意味着在<code>if</code>语句、<code>switch</code>语句、<code>for</code>循环、<code>while</code>循环中无法支持块级作用域。也就是说，ES6之前的JavaScript并不能构建类似Java中的那样的块级作用域（变量不能在语句块外被访问到）。但是，从ES6开始，你可以通过<code>let</code>关键字来定义变量，它修正了<code>var</code>关键字的缺点，能够让你像Java那样定义变量，并且支持块级作用域。看两个例子：</p>
<p>ES6之前，我们使用<code>var</code>关键字定义变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">  if(true) &#123;</span><br><span class="line">    var tmp &#x3D; 123;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(tmp);  &#x2F;&#x2F; 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以能够被访问，是因为<code>var</code>关键字声明的变量有一个变量提升的过程。在ES6的场景，推荐使用<code>let</code>关键字定义变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">  if(true) &#123;</span><br><span class="line">    let tmp &#x3D; 123;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(tmp);  ReferenceError: tmp is not defined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式，能够避免很多错误</p>
<h3 id="什么是this上下文"><a href="#什么是this上下文" class="headerlink" title="什么是this上下文"></a>什么是<code>this</code>上下文</h3><p>上下文通常取决于函数是如何被调用的。当一个函数被作为对象中的一个方法被调用的时候，<code>this</code>被设置为调用该方法的对象上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  foo: function()&#123;</span><br><span class="line">    alert(this &#x3D;&#x3D;&#x3D; obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo();  &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<p>这个准则也适用于当调用函数时使用<code>new</code>操作符来创建对象的实例的情况。在这种情况下，在函数的作用域内部<code>this</code>的值被设置为新创建的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  alert(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new foo();  &#x2F;&#x2F;foo</span><br><span class="line">foo(); &#x2F;&#x2F;window</span><br></pre></td></tr></table></figure>
<p>当调用一个为绑定函数时，<code>this</code>默认情况下是全局上下文，在浏览器中指向<code>window</code>对象。需要注意的是，ES5引入了严格模式的概念，如果启用了严格模式，此时上下文默认为<code>undefined</code>。</p>
<h3 id="执行环境（execution-context）"><a href="#执行环境（execution-context）" class="headerlink" title="执行环境（execution context）"></a>执行环境（execution context）</h3><p>JavaScript是一个单线程语言，意味着同一时间只能执行一个任务。当JavaScript解释器初始化执行代码时，它首先默认进入全局执行环境（execution context），从此刻开始，函数的每次调用都会创建一个新的执行环境。<br>这里会经常引起新手的困惑，这里提到了一个新的术语——执行环境（execution context），它定义了变量或函数有权访问的其它数据，决定了他们各自的行为。它更偏向于作用域的作用，而不是我们前面讨论的上下文（Context）。请务必仔细的区分执行环境 和 上下文这两个概念（注：英文容易造成混淆）。 说实话，这是个非常糟糕的命名约定，但是它是ECMAScript 规范制定的，你还是遵守吧。</p>
<p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的执行环境就会被推入一个环境栈中（execution stack）。在函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着。</p>
<p>执行环境可以分为创建和执行两个阶段。在创建阶段，解析器首先会创建一个变量对象（variable object，也成为活动对象 activation object），它由定义在执行环境中的变量、函数声明和参数组成。在这个阶段，作用域链会被初始化，<code>this</code>的值也会被最终确定。在执行阶段，代码被解释执行。</p>
<p>每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。需要知道，我们无法手动访问这个对象，只有解释器才能访问它。</p>
<h3 id="作用域链（The-Scope-Chain）"><a href="#作用域链（The-Scope-Chain）" class="headerlink" title="作用域链（The Scope Chain）"></a>作用域链（The Scope Chain）</h3><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链包含了在环境栈中的每个执行环境对应的变量对象。通过作用域链，可以决定变量的访问和标识符的解析。注意，全局执行环境的变量对象始终都是作用域链的最后一个对象。我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var color &#x3D; &quot;blue&quot;;</span><br><span class="line"></span><br><span class="line">function changeColor() &#123;</span><br><span class="line">  var anotherColor &#x3D; &quot;red&quot;;</span><br><span class="line">  </span><br><span class="line">  function swapColor() &#123;</span><br><span class="line">    var tempColor &#x3D; anotherColor;</span><br><span class="line">    anotherColor &#x3D; color;</span><br><span class="line">    color &#x3D; tempColor;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 这里可以访问color, anotherColor, 和 tempColor</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 这里可以访问color 和 anotherColor, 但是不能访问tempColor</span><br><span class="line">  swapColor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里只能访问color</span><br><span class="line">console.log(&quot;Color is now &quot; + color);</span><br></pre></td></tr></table></figure>
<p>上述代码一共包括三个执行环境： 全局环境、changeColor()的局部环境、swapColors()的局部环境。</p>
<p>从上图发现。内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性的、有次序的。<br>对于标识符解析（变量名或函数名搜索）是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级的向后（全局执行环境）回溯，直到找到标识符为止。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。换句话说，在函数内定义一个嵌套的函数时，就构成了一个闭包，它允许嵌套函数访问外层函数的变量。通过返回嵌套函数，允许你维护对外部函数中局部变量、参数、和内函数声明的访问。这种封装允许你在外部作用域中隐藏和保护执行环境，并且暴露公共接口，进而通过公共接口执行进一步的操作。可以看个简单的例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var localVariable &#x3D; &#39;private variable&#39;;</span><br><span class="line">  return function bar() &#123;</span><br><span class="line">    return localVariable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getLocalVariable &#x3D; foo();</span><br><span class="line">getLocalVariable();  &#x2F;&#x2F; private variable</span><br></pre></td></tr></table></figure>

<p>模块模式最流行的闭包类型之一，它允许你模拟公共的、私有的、和特权成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var Module &#x3D; (function()&#123;</span><br><span class="line">  var privateProperty &#x3D; &#39;foo&#39;;</span><br><span class="line">  </span><br><span class="line">  function privateMethod(args) &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return &#123;</span><br><span class="line">    publicProperty: &#39;&#39;,</span><br><span class="line">    </span><br><span class="line">    publicMethod: function(args) &#123;</span><br><span class="line">      &#x2F;&#x2F; do something</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    privilegeMethod: function(args) &#123;</span><br><span class="line">      return privateMethod(args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>模块类似于一个单例对象。由于在上面的代码中我们利用了<code>(function() { ... })();</code>的匿名函数形式，因此当编译器解析它的时候会立即执行。在闭包的执行上下文的外部唯一可以访问是位于返回对象中的公共方法和属性。然而，因为执行上下文被保存的缘故，所有的私有属性和方法将一直存在于应用的整个生命周期，这意味着我们只有通过公共方法才能和它们交互。</p>
<p>另一种类型的闭包被称为<em>立即执行的函数表达式(iife)</em>。其实它很简单，只不过是一个在全局环境中自执行的匿名函数而已：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(function(window)&#123;</span><br><span class="line">  var foo, bar;</span><br><span class="line">  </span><br><span class="line">  function private()&#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  window.Module &#x3D; &#123;</span><br><span class="line">    public: function()&#123;</span><br><span class="line">      &#x2F;&#x2F; do something</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(this);</span><br></pre></td></tr></table></figure>
<p>对于保护全局命名空间免受变量污染而言，这种表达式非常有用，它通过构建函数作用域的形式将变量与全局命名空间隔离，并通过闭包的形式让它们存在于整个运行时(runtime)。在很多应用和框架中，这种封装源代码的方式非常的流行，通常都是通过暴露一个单一的全局接口的方式与外部进行交互。</p>
<h3 id="Call-和-Apply"><a href="#Call-和-Apply" class="headerlink" title="Call 和 Apply"></a>Call 和 Apply</h3><p>这两个方法内建在所有的函数中（它们是<code>Function</code>对象的原型方法），允许你在自定义上下文中执行函数。不同点在于，<code>call</code>函数需要参数列表，而<code>apply</code>需要你提供一个参数数组。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function f(a, b) &#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将函数f作为o的方法，实际上就是重新设置函数f的上下文</span><br><span class="line">f.call(o, 1, 2);  &#x2F;&#x2F; 3</span><br><span class="line">f.apply(o, [1, 2]); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>两个结果是相同的，函数<code>f</code>在对象<code>o</code>的上下文中被调用，并提供了两个相同的参数<code>1</code>和<code>2</code>。</p>
<p>在ES5中引入了<code>Function.prototype.bind</code>方法，用于控制函数的执行上下文，它会返回一个新的函数，并且这个新函数会被永久的绑定到<code>bind</code>方法的第一个参数所指定的对象上，无论该函数如何被使用。它通过闭包将函数引导到正确的上下文中。对于低版本的浏览器，我们可以简单地对它进行实现如下(polyfill)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(!(&#39;bind&#39; in Function.prototype)) &#123;</span><br><span class="line">  Function.prototype.bind &#x3D; function()&#123;</span><br><span class="line">    var fn &#x3D; this,</span><br><span class="line">      context &#x3D; arguments[0],</span><br><span class="line">      args &#x3D; Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    return function()&#123;</span><br><span class="line">      return fn.apply(context, args.concat(arguments));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bind()</code>方法通常被用在上下文丢失的场景下，例如面向对象和事件处理。之所以要这么做，是因为节点的<code>addEventListener</code>方法<strong>总是为事件处理器所绑定的节点的上下文</strong>中执行回调函数，这就是它应该表现的那样。但是，如果你想要使用高级的面向对象技术，或需要你的回调函数成为某个方法的实例，你讲需要手动调整上下文。这就是<code>bind</code>方法所带来的便利之处:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function MyClass()&#123;</span><br><span class="line">  this.element &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">  this.element.addEventListener(&#39;click&#39;, this.onClick.bind(this), false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.onClick &#x3D; function(e)&#123;</span><br><span class="line">  &#x2F;&#x2F; do something</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回顾上面’bind’方法的源代码，你可能会注意到有两次调用涉及到了Array的slice方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments, 1);</span><br><span class="line">[].slice.call(arguments);</span><br></pre></td></tr></table></figure>
<p>我们知道，<code>arguments</code>对象并不是一个真正的数组，而是一个类数组对象，虽然具有length属性，并且值也能够被索引，但是他们不支持原生的数组方法，例如<code>slice</code>和<code>push</code>。但是，由于它们具有和数组类似的行为，数组的方法能够被调用和劫持，因此我们可以通过类似于上面代码的方式达到这个目的，其核心是利用<code>call</code>方法。</p>
<p>这种调用其他对象方法的技术也可以被应用到面向对象中，我们可以在JavaScript中模拟经典的继承方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass.prototype.init &#x3D; function()&#123;</span><br><span class="line">  &#x2F;&#x2F; call the superclass init method in the context of the &quot;MyClass&quot; instance</span><br><span class="line">  MySuperClass.prototype.init.apply(this, arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是利用<code>call</code>或<code>apply</code>在子类（MyClass）的实例中调用超类（MySuperClass）的方法。</p>
<h3 id="ES6中的箭头函数"><a href="#ES6中的箭头函数" class="headerlink" title="ES6中的箭头函数"></a>ES6中的箭头函数</h3><p>ES6中的箭头函数可以作为<code>Function.prototype.bind()</code>的替代品。和普通函数不同，箭头函数没有它自己的<code>this</code>值，它的<code>this</code>值继承自外围作用域。<br>对于普通函数而言，它总会自动接收一个<code>this</code>值，<code>this</code>的指向取决于它调用的方式。我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  </span><br><span class="line">  addAll: function(pieces) &#123;</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    _.each(pieces, function(piece)&#123;</span><br><span class="line">      aelf.add(piece);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，最直接的想法是直接使用<code>this.add(piece)</code>,但不幸的是，在JavaScript中你不能这么做，因为<code>each</code>的回调函数并未从外层继承<code>this</code>值。在该回调函数中，<code>this</code>的值为<code>window</code>或<code>undefined</code>，因此，我们使用临时变量self来将外部的<code>this</code>值导入内部。我们还有两种方法解决这个问题：<br><strong>使用ES5中的bind()方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  </span><br><span class="line">  addAll: function(pieces) &#123;</span><br><span class="line">    _.each(pieces, function(piece) &#123;</span><br><span class="line">      this.add(piece);</span><br><span class="line">    &#125;.bind(this));</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用ES6中的箭头函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  </span><br><span class="line">  addAll: function(pieces) &#123;</span><br><span class="line">    _.each(pieces, piece &#x3D;&gt; this.add(piece));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ES6版本中，<code>addAll</code>方法从它的调用者处获得了<code>this</code>值，内部函数是一个箭头函数，所以它继承了外部作用域的<code>this</code>值。</p>
<p>注意：对回调函数而言，在浏览器中，回调函数中的<code>this</code>为<code>window</code>或<code>undefined</code>（严格模式），而在Node.js中，回调函数的<code>this</code>为<code>global</code>。实例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function hello(a, callback) &#123;</span><br><span class="line">  callback(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello(&#39;weiwei&#39;, function(a) &#123;</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; global); &#x2F;&#x2F; true</span><br><span class="line">  console.log(a); &#x2F;&#x2F; weiwei</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在你学习高级的设计模式之前，理解这些概念非常的重要，因为作用域和上下文在现代JavaScript中扮演着最基本的角色。无论我们谈论的是闭包、面向对象、继承、或者是各种原生实现，上下文和作用域都在其中扮演着至关重要的角色。如果你的目标是精通JavaScript语言，并且深入的理解它的各个组成，那么作用域和上下文便是你的起点。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/" target="_blank" rel="noopener">Understanding Scope and Context in JavaScript</a></li>
<li>JavaScript 高级程序设计，section 4.2</li>
<li><a href="http://www.2ality.com/2016/02/arrow-functions-vs-bind.html" target="_blank" rel="noopener">Arrow function vs. bind()</a></li>
<li><a href="http://www.html-js.com/article/Sexy-Javascript-understand-the-callback-function-with-the-use-of-Javascript-in" target="_blank" rel="noopener">理解与使用JavaScript中的回调函数</a></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#上下文（Context）和作用域（Scope）"><span class="toc-number">1.</span> <span class="toc-text">上下文（Context）和作用域（Scope）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量作用域"><span class="toc-number">1.1.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是this上下文"><span class="toc-number">1.2.</span> <span class="toc-text">什么是this上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行环境（execution-context）"><span class="toc-number">1.3.</span> <span class="toc-text">执行环境（execution context）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域链（The-Scope-Chain）"><span class="toc-number">1.4.</span> <span class="toc-text">作用域链（The Scope Chain）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-number">1.5.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Call-和-Apply"><span class="toc-number">1.6.</span> <span class="toc-text">Call 和 Apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6中的箭头函数"><span class="toc-number">1.7.</span> <span class="toc-text">ES6中的箭头函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">2.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=r0ger1tlearn.com/2017/10/18/context-and-scope/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&text=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&title=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&is_video=false&description=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=理解JavaScript中的作用域和上下文&body=Check out this article: r0ger1tlearn.com/2017/10/18/context-and-scope/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&title=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&title=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&title=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&title=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=r0ger1tlearn.com/2017/10/18/context-and-scope/&name=理解JavaScript中的作用域和上下文&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=r0ger1tlearn.com/2017/10/18/context-and-scope/&t=理解JavaScript中的作用域和上下文" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2023
    boyongjiong
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
